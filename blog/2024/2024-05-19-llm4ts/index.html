<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <h1 id="llm4ts-two-stage-fine-tuning-for-time-series-forecasting-with-pre-trained-llms">LLM4TS: Two-Stage Fine-Tuning for Time-Series Forecasting with Pre-Trained LLMs</h1> <p>这里我主要说明一下<strong>Method</strong>：</p> <p><img src="/pic/llm4ts/structure.jpg" alt="整体架构"></p> <h2 id="time-series-alignment">Time-Series Alignment</h2> <p>对时间序列数据进行自回归处理，分析输入和输出之间的关系。</p> <h3 id="1-instance-normalization">1. Instance Normalization</h3> <p>针对整个数据实例进行归一化处理，是数据预处理的一部分。</p> <h3 id="2-time-series-tokenization">2. Time-Series Tokenization</h3> <p>通过通道独立策略加上patching处理，这是一种非常典型的数据处理方法。 <img src="/pic/llm4ts/patch.jpg" alt="时间序列Tokenization示意图"></p> <h3 id="3-three-encodings-for-patched-time-series-data">3. Three Encodings for Patched Time-Series Data</h3> <ul> <li> <strong>Token嵌入层</strong>：使用一维卷积基层作为token嵌入层。</li> <li> <strong>位置层</strong>：使用可训练的查找表标识每个patch的位置。</li> <li> <strong>时间嵌入层</strong>：实现双级聚合。 <ul> <li>首先，为每个时间属性（如秒、分钟等）使用一个可训练的查找表，将每个属性映射到一个高维空间中，然后将这些映射求和，形成一个统一的时间嵌入表示。</li> <li>每个patch可能包含多个时间戳，采用池化方法来提取最终的时间嵌入，通常使用片段中的第一个时间戳作为整个片段的代表。</li> </ul> </li> </ul> <h3 id="4-partial-freezing-and-tunable-layers">4. Partial Freezing and Tunable Layers</h3> <p>冻结模型的某些部分，同时保留部分层为可训练状态，以优化模型性能。</p> <ul> <li><strong>Layer Normalization Tuning</strong></li> <li><strong>Low-Rank Adaptation (LoRA)</strong></li> </ul> <h2 id="forecasting-fine-tuning-strategy">Forecasting Fine-Tuning Strategy</h2> <p>采用initial linear probing followed by full fine-tuning (LP-FT)策略，这一策略的优越性在于其双阶段方法：</p> <ul> <li>首先优化输出层，以最小化微调中的调整量（保留特征提取器在OOD（Out-Of-Distribution）场景中的有效性）。</li> <li>然后进行全面的微调，以使模型适应特定任务（提高ID（In-Distribution）精度）。</li> </ul> </body></html>